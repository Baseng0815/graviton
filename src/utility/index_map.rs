use bitvec::prelude::BitVec;
use itertools::Itertools;
use std::fmt::Debug;
use std::hash::Hash;
use std::marker::PhantomData;
use std::ops::{
    Index,
    IndexMut,
    Range,
};
use std::slice::Iter;
use std::vec::IntoIter;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum IndexMapError {
    #[error("Trying to create an index from an invalid value ({0}).")]
    InvalidIndex(usize),
}

/// Marker trait for keys that can be used with a [PrimaryMap].
/// New keys may be created with the [new_map_key] macro.
/// It is highly discouraged to manually implement this trait.
#[allow(private_bounds)]
pub trait MapKey: Copy + PartialEq + Eq + PartialOrd + Ord + Hash {
    /// Tries to create a new key from the provided index. If Index is the maximum value, this will result
    /// in an error.
    fn try_from_index(index: usize) -> Result<Self, IndexMapError>;
    fn to_index(&self) -> usize;
}

#[macro_export(local_inner_macros)]
/// Creates a new key type for indexing [PrimaryMap] and [SecondaryMap].
/// The keys are guaranteed to be non-zero, facilitating optimizations when using e.g. [Option]
#[cfg(feature = "serde")]
macro_rules! new_map_key {
    ( $(#[$outer:meta])* $vis:vis struct $name:ident; $display_prefix:literal;) => {
        $(#[$outer])*
        #[derive(Debug, Eq, PartialEq, PartialOrd, Ord, Copy, Clone, Hash)]
        #[derive(serde::Serialize, serde::Deserialize)]
        #[repr(transparent)]
        $vis struct $name(std::num::NonZero<usize>);

        map_key_display!($name, $display_prefix);
        map_key_trait!($name, usize::try_from);
    };
}

#[macro_export(local_inner_macros)]
#[cfg(not(feature = "serde"))]
macro_rules! new_map_key {
    ( $(#[$outer:meta])* $vis:vis struct $name:ident; $display_prefix:literal;) => {
        $(#[$outer])*
        #[derive(Debug, Eq, PartialEq, PartialOrd, Ord, Copy, Clone, Hash)]
        #[repr(transparent)]
        $vis struct $name(std::num::NonZero<usize>);

        map_key_display!($name, $display_prefix);
        map_key_trait!($name, usize::try_from);
    };
}

#[macro_export(local_inner_macros)]
/// Creates a new key type for indexing [PrimaryMap] and [SecondaryMap].
/// The keys are guaranteed to be non-zero, facilitating optimizations when using e.g. [Option]
/// The keys generated by this macro have a size of 16 bit.
#[cfg(feature = "serde")]
macro_rules! new_map_key_8 {
    ( $(#[$outer:meta])* $vis:vis struct $name:ident; $display_prefix:literal;) => {
        $(#[$outer])*
        #[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Hash)]
        #[derive(serde::Serialize, serde::Deserialize)]
        #[repr(transparent)]
        $vis struct $name(std::num::NonZero<u8>);

        map_key_display!($name, $display_prefix);
        map_key_trait!($name, u8::try_from);
    };
}
#[macro_export(local_inner_macros)]
#[cfg(not(feature = "serde"))]
macro_rules! new_map_key_8 {
    ( $(#[$outer:meta])* $vis:vis struct $name:ident; $display_prefix:literal;) => {
        $(#[$outer])*
        #[derive(Debug, Eq, PartialEq, Copy, Clone, Hash)]
        #[repr(transparent)]
        $vis struct $name(std::num::NonZero<u8>);

        map_key_display!($name, $display_prefix);
        map_key_trait!($name, u8::try_from);
    };
}

#[macro_export(local_inner_macros)]
/// Creates a new key type for indexing [PrimaryMap] and [SecondaryMap].
/// The keys are guaranteed to be non-zero, facilitating optimizations when using e.g. [Option]
/// The keys generated by this macro have a size of 16 bit.
#[cfg(feature = "serde")]
macro_rules! new_map_key_16 {
    ( $(#[$outer:meta])* $vis:vis struct $name:ident; $display_prefix:literal;) => {
        $(#[$outer])*
        #[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Hash)]
        #[derive(serde::Serialize, serde::Deserialize)]
        #[repr(transparent)]
        $vis struct $name(std::num::NonZero<u16>);

        map_key_display!($name, $display_prefix);
        map_key_trait!($name, u16::try_from);
    };
}

#[macro_export(local_inner_macros)]
#[cfg(not(feature = "serde"))]
macro_rules! new_map_key_16 {
    ( $(#[$outer:meta])* $vis:vis struct $name:ident; $display_prefix:literal;) => {
        $(#[$outer])*
        #[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Hash)]
        #[repr(transparent)]
        $vis struct $name(std::num::NonZero<u16>);

        map_key_display!($name, $display_prefix);
        map_key_trait!($name, u16::try_from);
    };
}

#[macro_export(local_inner_macros)]
#[cfg(not(feature = "serde"))]
macro_rules! new_map_key_32 {
    ( $(#[$outer:meta])* $vis:vis struct $name:ident; $display_prefix:literal;) => {
        $(#[$outer])*
        #[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Hash)]
        #[repr(transparent)]
        $vis struct $name(std::num::NonZero<u32>);

        map_key_display!($name, $display_prefix);
        map_key_trait!($name, u32::try_from);
    };
}

#[macro_export(local_inner_macros)]
macro_rules! map_key_display {
    ($name:ident, $display_prefix:literal) => {
        impl std::fmt::Display for $name {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::fmt::Result {
                std::write!(f, "{}{}", $display_prefix, self.0.get() - 1)
            }
        }
    };
}
#[macro_export(local_inner_macros)]
macro_rules! map_key_trait {
    ($name:ident, $backing_type_conversion:path) => {
        impl MapKey for $name {
            fn try_from_index(index: usize) -> Result<Self, crate::utility::index_map::IndexMapError> {
                std::num::NonZero::new(
                    $backing_type_conversion(index + 1)
                        .map_err(|e| crate::utility::index_map::IndexMapError::InvalidIndex(index))?,
                )
                .ok_or(crate::utility::index_map::IndexMapError::InvalidIndex(index))
                .map(Self)
            }
            fn to_index(&self) -> usize {
                // This is safe, since self.0 is never zero
                unsafe { usize::try_from(self.0.get().unchecked_sub(1)).unwrap() }
            }
        }
    };
}

#[derive(Debug)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PrimaryMap<K: MapKey, V> {
    data: Vec<V>,
    phantom_data: PhantomData<K>,
}

impl<K: MapKey, V> PrimaryMap<K, V> {
    pub fn with_capacity(capacity: usize) -> Self {
        Self {
            data: Vec::with_capacity(capacity),
            phantom_data: Default::default(),
        }
    }

    pub fn shrink_to_fit(&mut self) {
        self.data.shrink_to_fit();
    }
    /// Gets the next key that will be used when inserting a value.
    pub fn next_key(&self) -> K {
        K::try_from_index(self.data.len()).expect("Index out of range")
    }

    pub fn insert(
        &mut self,
        value: V,
    ) -> K {
        let key = self.next_key();
        self.data.push(value);
        key
    }

    pub fn get(
        &self,
        key: K,
    ) -> Option<&V> {
        self.data.get(key.to_index())
    }

    pub fn get_mut(
        &mut self,
        key: K,
    ) -> Option<&mut V> {
        self.data.get_mut(key.to_index())
    }

    pub fn len(&self) -> usize {
        self.data.len()
    }

    pub fn first(&self) -> Option<&V> {
        self.data.first()
    }

    pub fn last(&self) -> Option<&V> {
        self.data.last()
    }

    pub fn keys(&self) -> impl ExactSizeIterator<Item = K> + DoubleEndedIterator + use<K, V> {
        (0..self.data.len())
            .map(MapKey::try_from_index)
            .map(Result::unwrap)
    }

    pub fn values(&self) -> impl ExactSizeIterator<Item = &V> + DoubleEndedIterator {
        self.data.iter()
    }

    pub fn values_mut(&mut self) -> impl ExactSizeIterator<Item = &mut V> + DoubleEndedIterator {
        self.data.iter_mut()
    }

    pub fn items(&self) -> impl ExactSizeIterator<Item = (K, &V)> + DoubleEndedIterator {
        self.data
            .iter()
            .enumerate()
            .map(|(k, v)| (MapKey::try_from_index(k).expect("Enumarating must produce a valid index"), v))
    }

    pub fn items_mut(&mut self) -> impl Iterator<Item = (K, &mut V)> {
        self.data
            .iter_mut()
            .enumerate()
            .map(|(k, v)| (MapKey::try_from_index(k).expect("Enumarating must produce a valid index"), v))
    }

    pub fn into_items(self) -> impl Iterator<Item = (K, V)> {
        self.data
            .into_iter()
            .enumerate()
            .map(|(k, v)| (MapKey::try_from_index(k).expect("Enumerating must produce a valid index"), v))
    }
}

impl<K, V> IntoIterator for PrimaryMap<K, V>
where
    K: MapKey,
{
    type Item = (K, V);
    type IntoIter = std::iter::Map<std::iter::Enumerate<IntoIter<V>>, fn((usize, V)) -> (K, V)>;

    fn into_iter(self) -> Self::IntoIter {
        self.data
            .into_iter()
            .enumerate()
            .map(|(k, v)| (MapKey::try_from_index(k).expect("Enumerating must produce a valid index"), v))
    }
}

impl<'a, K, V> IntoIterator for &'a PrimaryMap<K, V>
where
    K: MapKey,
{
    type Item = (K, &'a V);
    // TODO: Replace type with ATIT once https://github.com/rust-lang/rust/issues/63063 is stable
    type IntoIter = std::iter::Map<std::iter::Enumerate<Iter<'a, V>>, fn((usize, &'a V)) -> (K, &'a V)>;

    fn into_iter(self) -> Self::IntoIter {
        self.data
            .iter()
            .enumerate()
            .map(|(k, v)| (MapKey::try_from_index(k).expect("Enumerating must produce a valid index"), v))
    }
}

impl<K: MapKey, V> Default for PrimaryMap<K, V> {
    fn default() -> Self {
        Self {
            data: Default::default(),
            phantom_data: Default::default(),
        }
    }
}

impl<K: MapKey, V: Clone> Clone for PrimaryMap<K, V> {
    fn clone(&self) -> Self {
        Self {
            data: self.data.clone(),
            phantom_data: Default::default(),
        }
    }
}

impl<K: MapKey, V> Index<K> for PrimaryMap<K, V> {
    type Output = V;

    fn index(
        &self,
        key: K,
    ) -> &Self::Output {
        // index - 1 is fine, since index is guaranteed to be non-zero
        &self.data[key.to_index()]
    }
}

impl<K: MapKey, V> IndexMut<K> for PrimaryMap<K, V> {
    fn index_mut(
        &mut self,
        key: K,
    ) -> &mut Self::Output {
        &mut self.data[key.to_index()]
    }
}

impl<K: MapKey, V> Index<Range<K>> for PrimaryMap<K, V> {
    type Output = [V];

    fn index(
        &self,
        key: Range<K>,
    ) -> &Self::Output {
        // index - 1 is fine, since index is guaranteed to be non-zero
        let index_start = key.start.to_index();
        let index_end = key.end.to_index();
        &self.data[index_start..index_end]
    }
}

impl<K: MapKey, V> IndexMut<Range<K>> for PrimaryMap<K, V> {
    fn index_mut(
        &mut self,
        key: Range<K>,
    ) -> &mut Self::Output {
        // index - 1 is fine, since index is guaranteed to be non-zero
        let index_start = key.start.to_index();
        let index_end = key.end.to_index();
        &mut self.data[index_start..index_end]
    }
}

impl<K: MapKey, V> FromIterator<(K, V)> for PrimaryMap<K, V> {
    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> Self {
        let mut collected: Vec<(K, V)> = iter.into_iter().collect();
        collected.sort_by_key(|(k, _)| k.to_index());

        if let Some((k, _)) = collected.first() {
            assert_eq!(k.to_index(), 0, "Keys must begin at 0");
        };

        for (&(k, _), &(k_next, _)) in collected.iter().zip(collected.iter().skip(1)) {
            assert_eq!(k_next.to_index(), k.to_index() + 1, "Keys must be consecutive");
        }

        Self {
            data: collected.into_iter().map(|(_, v)| v).collect_vec(),
            phantom_data: Default::default(),
        }
    }
}

#[derive(Debug)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SecondaryMap<K: MapKey, V> {
    data: Vec<V>,
    default: V,
    phantom_data: PhantomData<K>,
}

impl<K, V> Clone for SecondaryMap<K, V>
where
    K: MapKey,
    V: Clone,
{
    fn clone(&self) -> Self {
        Self {
            data: self.data.clone(),
            default: self.default.clone(),
            phantom_data: Default::default(),
        }
    }
}

impl<K, V> Default for SecondaryMap<K, V>
where
    K: MapKey,
    V: Default,
{
    fn default() -> Self {
        Self {
            data: Default::default(),
            default: V::default(),
            phantom_data: Default::default(),
        }
    }
}

impl<K, V> Index<K> for SecondaryMap<K, V>
where
    K: MapKey,
{
    type Output = V;

    fn index(
        &self,
        index: K,
    ) -> &Self::Output {
        self.data.get(index.to_index()).unwrap_or(&self.default)
    }
}

impl<K, V> IndexMut<K> for SecondaryMap<K, V>
where
    K: MapKey,
    V: Default,
{
    /// Access to the secondary map causes the underlying vector to reallocate to fit the provided index.
    /// The secondary map will be at most as large as the original map, if only valid keys are used.
    fn index_mut(
        &mut self,
        index: K,
    ) -> &mut Self::Output {
        let index = index.to_index();
        if index >= self.data.len() {
            self.data.resize_with(index + 1, Default::default);
        }
        &mut self.data[index]
    }
}

impl<K, V> SecondaryMap<K, V>
where
    K: MapKey,
{
    pub fn get(
        &self,
        index: &K,
    ) -> Option<&V> {
        self.data.get(index.to_index())
    }

    pub fn items(&self) -> impl Iterator<Item = (K, &V)> {
        self.data
            .iter()
            .enumerate()
            .map(|(k, v)| (MapKey::try_from_index(k).expect("Enumarating must produce a valid index"), v))
    }
}

#[derive(Debug, Clone)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SecondarySet<K: MapKey> {
    data: BitVec,
    phantom_data: PhantomData<K>,
}

impl<K: MapKey> Default for SecondarySet<K> {
    fn default() -> Self {
        Self {
            data: BitVec::new(),
            phantom_data: Default::default(),
        }
    }
}

impl<K> SecondarySet<K>
where
    K: MapKey,
{
    pub fn contains(
        &self,
        index: K,
    ) -> bool {
        self.data
            .get(index.to_index())
            .map(|v| v == true)
            .unwrap_or(false)
    }

    pub fn add(
        &mut self,
        index: K,
    ) {
        let index = index.to_index();
        if index >= self.data.len() {
            self.data.resize(index + 1, false);
        }
        self.data.set(index, true);
    }

    pub fn remove(
        &mut self,
        index: K,
    ) {
        let index = index.to_index();
        if index < self.data.len() {
            self.data.set(index, false);
        }
    }
}
